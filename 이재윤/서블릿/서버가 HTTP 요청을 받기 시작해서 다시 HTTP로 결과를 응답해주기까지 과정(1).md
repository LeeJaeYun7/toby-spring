


```
Summary

(1) DisptacherServlet의 HTTP 요청 접수
- 자바 서버의 서블릿 컨테이너는 HTTP 프로토콜을 통해 들어오는 요청이 스프링의 DispatcherServlet에 할당된 것이라면,
  HTTP 요청 정보를 DispatcherServlet에 전달해준다.
-> Web.xml에는 보통 리스트 3-2와 같이 DispatcherServlet이 전달받을 URL의 패턴이 정의되어 있다.

- 이 서블릿-매핑은 URL이 /app로 시작하는 모든 요청을 스프링의 프론트 컨트롤러인 DispatcherServlet에게 할당해주는 것이다.
-> 리스트 3-2에서처럼 특정 폴더 아래의 내용을 매핑하는 방법도 가능하고, *.do와 같이 특정 확장자만을 매핑해주는 방법도 쓸 수 있다.

- HTTP 요청은 HTTP 명령에 따라서 GET과 POST로 구분된다.
-> 어떤 명령을 사용하든 HTTP 요청에는 해당 요청을 통해서 사용자가 전달하려고 하는 정보가 전송된다.
-> 이 정보는 URL의 '?'뒤에 이어지는 쿼리 스트링이나 폼 파라미터, 쿠키나 헤더 정보를 통해 전달될 수 있다.

- DispatcherServlet은 모든 요청에 대해 공통적으로 진행해야 하는 전처리 작업이 등록된 것이 있다면 이를 먼저 수행한다.
-> 공통적으로 이용 가능한 보안이나 파라미터 조작, 한글 디코딩과 같은 작업이 적용된다.


(2) DispatcherServlet에서 컨트롤러로 HTTP 요청 위임
- DispatcherServlet은 URL이나 파라미터 정보, HTTP 명령 등을 참고로 해서 어떤 컨트롤러에게 작업을 위임할지 결정한다.
-> 컨트롤러를 선정하는 것은 DispatcherServlet의 핸들러 매핑 전략을 이용한다.
-> 스프링에서는 컨트롤러를 핸들러라고도 부른다.
-> 웹의 요청을 다루는 오브젝트라는 의미다.
-> 사용자 요청을 기준으로 어떤 핸들러에게 작업을 위임할지를 결정해주는 것을 핸들러 매핑 전략이라고 한다.

- 이를 전략이라고 부르는 이유는 DI의 가장 대표적인 용도라고 할 수 있는 전략 패턴이 적용되어 있기 때문이다.
-> DispatcherServlet의 핸들러 매핑 전략은 DispatcherServlet의 수정 없이도 DI를 통해 얼마든지 확장 가능하다.
-> 어떤 URL이 들어오면 어떤 컨트롤러 오브젝트가 이를 처리하게 할지를 매핑해주는 전략을 만들어서 DI로 제공해주기만 하면된다.
-> 엄밀히 말하면 DispatcherServlet은 그 자체로 스프링 컨텍스트에 등록되는 빈이 아니므로 DI가 일어나는 것은 아니다.
-> 하지만 마치 DI가 적용되는 것처럼 서블릿 애플리케이션 컨텍스트의 빈을 가져와 사용한다.
-> 이 때, 특정 인터페이스를 구현한 빈을 자동으로 찾아오는 자동와이어링 기법을 이용한다.

- 어떤 컨트롤러/핸들러가 요청을 처리하게 할지를 결정했다면, 다음은 해당 컨트롤러 오브젝트의 메소드를 호출해서
    실제로 웹 요청을 처리하는 작업을 위임할 차례다.
-> 그런데 DispatcherServlet이 매핑으로 찾은 컨트롤러를 가져와 실행하려면 컨트롤러 메소드를 어떻게 호출할지를 알고 있어야 한다.
-> 그렇다면 DispatcherServlet에서 호출 가능한 컨트롤러는 특정 인터페이스를 구현해야 한다는 식의 규약을 따라서 작성해야 할까?
-> 그건 아니다. DispatcherServlet이 요청을 위임하는 대상인 컨트롤러에는 아무런 제약이나 선결 조건이 없다는 뜻이다.
-> DispatcherServlet은 어떤 종류의 오브젝트라도 컨트롤러로 사용할 수 있다.
-> 이것이 DispatcherServlet이 갖는 무한한 확장성의 비결이다.
-> DispatcherSErvlet에는 어떤 컨트롤러라도 사용 가능하다.

- 하지만 자바의 오브젝트 사이에 무엇인가 요청이 전달되려면 메소드가 호출돼야 하고,
    그러려면 DispatcherServlet이 컨트롤러 오브젝트의 메소드를 호출할 수 있는 방법이 있어야 하지 않는가?
-> 어떻게 제각각 다른 메소드와 포맷을 가진 오브젝트를 컨트롤러로 만들어놓고 DispatcherServlet이 이를 알아서 호출하게 만들 수 있을까?

- 해결책은 어댑터를 이용하는 것이다. 전형적인 오브젝트 어댑터 패턴을 사용해서, 특정 컨트롤러를 호출해야 할 때는 해당 컨트롤러 타입을 지원하는
  어댑터를 중간에 껴서 호출하는 것이다.
-> 그러면 DispatcherServlet은 항상 일정한 방식으로 컨트롤러를 호출하고 결과를 받을 수 있다.

- 그림 3-2는 DispatcherServlet과 컨트롤러 사이의 호출 방법을 자세하게 보여준다.
-> DispatcherServlet은 컨트롤러가 어떤 메소드를 가졌고 어떤 인터페이스를 구현했는지 전혀 알지 못한다.
-> 대신 컨트롤러의 종류에 따라 적절한 어댑터를 사용한다.
-> 각 어댑터는 자신이 담당하는 컨트롤러에 맞는 호출 방법을 이용해서 컨트롤러에 작업 요청을 보내고,
   결과를 돌려받아서 DispatcherServlet에게 다시 돌려주는 기능을 갖고 있다.

- 이렇게 하면 하나의 DispatcherServlet이 동시에 여러 가지 타입의 컨트롤러를 사용할 수 있다.
-> 스프링 서블릿/MVC 확장 구조의 기본은 바로 어댑터를 통한 컨트롤러 호출 방식이다.
-> 어떤 어댑터를 사용할지는 DispatcherServlet 전략의 하나인 핸들러 어댑터 전략을 통해 결정한다.
-> 당연히 DI를 통해 자유롭게 확장 가능하다.

- DispatcherServlet이 핸들러 어댑터에 웹 요청을 전달할 때는 모든 웹 요청 정보가 담긴 HttpServletRequest 타입의 오브젝트를 전달해준다.
-> 이를 어댑터가 적절히 변환해서 컨트롤러의 메소드가 받을 수 있는 파라미터로 변환해서 전달해주는 것이다.
-> HttpServletResponse도 함께 전달해준다.
-> 드물긴 하지만 컨트롤러가 결과를 리턴값으로 돌려주는 대신 HttpServletResponse 오브젝트 안에 직접 집어넣을 수도 있기 때문이다.


(3) 컨트롤러의 모델 생성과 정보 등록

- MVC 패턴의 장점은 정보를 담고 있는 모델과 정보를 어떻게 뿌려줄지를 알고 있는 뷰가 분리된다는 점이다.
-> 같은 모델이지만 다른 뷰에 전달되면 다른 방식으로 모델의 정보가 출력되게 할 수 있다.
-> 테이블 뷰에 전달되면 테이블 구조로 나타날 것이고, 그래프 뷰에 전달되면 그래프로, 엑셀 뷰라면 엑셀 문서르 표현된다.

- 컨트롤러의 작업을 먼저 사용자 요청을 해석하는 것, 그에 따라 실제 비즈니스 로직을 수행하도록 서비스 계층 오브젝트에게 작업을 위임하는 것,
  그리고 결과를 받아서 모델을 생성하는 것, 마지막으로 어떤 뷰를 사용할지 결정하는 것의 네 가지로 분류할 수 있다.

- 모델을 생성하고 모델에 정보를 넣어주는 게 컨트롤러가 해야 할 마지막 중요한 두 가지 작업 중 하나다.
-> 컨트롤러가 어떤 식으로든 다시 DispatcherServlet에 돌려줘야 할 두 가지 정보가 있는데,
   그 중 하나가 모델이고 다른 하나가 뷰다.

- 모델은 보통 맵에 담긴 정보라고 생각하면 된다.
-> 이름과 그에 대응되는 값의 쌍으로 정보를 만드는 것이다.
-> 물론 복잡한 오브젝트 그래프를 갖는 컬렉션을 하나의 모델 값으로 추가해도 상관없다.
-> 모델은 이름과 오브젝트 값의 쌍으로 만들어진다는 사실만 기억하자.

  

Insight
- DispatcherServlet의 구체적인 동작 과정

Application
- 핸들러 어댑터, 핸들러 매핑 코드 뜯어보기 


```
